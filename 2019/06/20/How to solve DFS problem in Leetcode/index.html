<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> How to Leetcode - DFS (To be finished) · Tech blog of Unicooo</title><meta name="description" content="How to Leetcode - DFS (To be finished) - Unicooo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://www.enginego.org" target="_blank" class="nav-list-link">编程基础</a></li><li class="nav-list-item"><a href="https://github.com/Windsooon" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">How to Leetcode - DFS (To be finished)</h1><div class="post-time">Jun 20, 2019</div><div class="post-content"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇文章我会专注在如何解决常见的 DFS 的问题，了解了基本模式之后，我相信面对大部分 DFS 问题都能够迎刃而解。我假定你对图的基础知识有一定的了解，例如什么是图，常见的图有那些，图的遍历类型有多少种。如果对这些还不熟悉的话，我建议你可以先找一本算法书学习一下，不然死记硬背解题方法的话毫无帮助，Leetcode常见的图都是无环图，所以我们这里也只讨论无环图。</p>
<h4 id="辨别问题"><a href="#辨别问题" class="headerlink" title="辨别问题"></a>辨别问题</h4><p>那么什么样的问题可以用 DFS 来解决呢？在 Leetcode 中，DFS 问题常见的表达形式为：</p>
<blockquote>
<p>“给定一个图（树，字符串，矩阵），找到在遍历图的过程中，符合特定条件的数值或路径。”</p>
</blockquote>
<p>（这里我把返回布尔值当成返回默认值或空路径的特殊情况），上面的这个定义有点抽象，举几个例子：</p>
<ul>
<li><p><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Leetcode 113 Path Sum II</a></p>
<blockquote>
<p>“Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.”</p>
<p>“给定一个有向无环图（非空二叉树），找到在遍历图的过程中，符合特定条件的数值（路径和等于 sum ）”</p>
</blockquote>
<pre><code>Given the below binary tree and sum = 22, 

input:

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1

output:

[
    [5,4,11,2],
    [5,8,4,5]
]
</code></pre></li>
</ul>
<ul>
<li><p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">Leetcode 200 Number of Islands</a></p>
<blockquote>
<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>“给定一个无向无环图（矩阵），找到在遍历图的过程中，符合特定条件的数值（岛的数量）”</p>
</blockquote>
<pre><code>Input:
11110
11010
11000
00000

Output: 1
</code></pre></li>
</ul>
<p>以上几个问题都是 Leetcode 中常见的 DFS 问题，只要你遵守以下的解题模式，那么即使在头脑空白的时候也能遵循一个固定的思路。很多 DFS 问题可以用 DP 来解决，通常效率也会更高。不过先实现 DFS 的解法然后优化成 DP 我觉得也是一个不错的选择。</p>
<h4 id="解题模式"><a href="#解题模式" class="headerlink" title="解题模式"></a>解题模式</h4><p>首先我们先定义要做的事情。</p>
<ol>
<li><p>遍历图</p>
<p> 注意，这里的遍历目标是遍历整个图，并不包括有环的图，如果根节点不能访问所有其他节点，<strong>那么就需要对每个节点进行 DFS 遍历</strong>。要注意，这里是理论上的，我们会可以记录已经遍历过的点，或者把这些点改为无效值来跳过。</p>
</li>
<li><p>DFS 递归函数</p>
<p> 这个函数是一个递归函数，具体形式我会在下面进行分析</p>
</li>
<li><p>返回结果</p>
</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ol>
<li>遍历图</li>
</ol>
<p>注意这里我把状态判断放到了遍历中，所以主函数需要处理一些边界条件</p>
<ol>
<li><p>从根节点可以访问所有其他节点（例子1）：</p>
<p>  function main_function(graph):</p>
<pre><code># 如果需要返回数值则创建变量（例如最大值，最小值）,路径则创建数组：
res = val // list[]
element = first element of graph
# 对根节点进行 DFS 遍历
dfs(element, res)
return res
</code></pre></li>
<li><p>否则（例子2)：</p>
<p>  function main_function(graph):</p>
<pre><code># 边界条件，例如如果图是空的，或者根节点本身就符合条件
res = val // list[]
# 对图里面每个元素进行 DFS 遍历
for in the matrix:
    dfs(element, res)
return res
</code></pre></li>
<li><p>这里有一个优化点，如果题目要求的返回值是布尔值的话，遍历图可以提前结束：</p>
<p>  function main_function(graph):</p>
<pre><code>res = val // list[]
for in the graph:
    if dfs(element, res) is True:
        return True
return False
</code></pre></li>
</ol>
<ol>
<li><p>DFS 递归函数</p>
<ol>
<li><p>找到需要遍历的子节点</p>
<p> 遍历的子节点有时候不好找，对于有向图来说，树结构通常是它的子树节点，字符串根据实际情况可以是其他任意一个字符。无向图如某些矩阵则可能是上下左右节点，或者下右节点，这些看题目要求，同时因为要防止重复遍历，所以这里可以使用一个小技巧，把当前节点的值设为无效，DFS 遍历结束再还原。（下面的可选 2），这里的 <strong>is_valid</strong> 和 <strong>match</strong> 都是子函数</p>
</li>
<li><p>函数实现</p>
<pre><code>function dfs(element, res, current, target, path):
    # 输入参数中，
    # element 代表需要遍历的节点
    # res 代表保存结果的最终容器
    # current 代表当前状态（可选）
    # target 代表目标状态
    # path 代表遍历路径（可选）

    # 遍历每一个子节点
    for each child in element:
        # 修改图的节点值为非法（可选 2.1）
        graph-&gt;val = unvalid value
        # 检查子节点是否合法，是否已经访问过，是否越界
        if is_valid(child):
            # 检查子节点与元素组成的新状态是否符合条件
            if match(current, child, target):
                # 更新最终结果
                res += new_res
            else:
                # 遍历所有合法子节点，更新状态
                dfs(child, res, current+child.val, target, path+child)
        # 恢复图的节点值（可选 2.2）
        graph-&gt;val = valid value

function is_valid(child):
    # 如果 child 合法则返回真，否则返回假

function match(current, child, target):
    # 如果当前 child 与 current 的组合满足题目与 target 的要求，则返回真
</code></pre></li>
</ol>
</li>
</ol>
<h4 id="原题分析"><a href="#原题分析" class="headerlink" title="原题分析"></a>原题分析</h4><p>把我们的套路放在第一个例子，我们可以这样写：（Python 代码）</p>
<pre><code>class Solution:
    def pathSum(self, root, sum):
        # 边界情况
        if not root:
            return []
        # 边界情况2，因为我们是在遍历中验证是否符合条件，所以这里要处理另外一个边界情况
        # 你也可以把验证放在 DFS 函数的开始，速度稍微慢点。
        if root.val == sum and not root.left and not root.right:
            return [[root.val]]
        # 因为根节点可以访问所有子节点，所以只需要遍历根节点
        return self.dfs(root, [], root.val, sum, [root.val])

    def dfs(self, node, res, current, target, path):
        # 遍历每一个子节点
        for n in [node.left, node.right]:
            # 检查子节点是否合法，是否已经访问过，是否越界
            if self.is_valid(n):
                # 检查子节点与元素组成的新状态是否符合条件
                if self.match(current, n, target):
                    # 更新最终结果
                    # 也可以用 res.append(path+[n.val])，不过会慢点
                    tem = path[:]
                    tem.append(n.val)
                    res.append(tem)
                else:
                    # 遍历所有合法子节点，更新状态
                    self.dfs(n, res, current+n.val, target, path+[n.val])
        return res

    def is_valid(self, node):
        # 子节点在不同的 path 中可以重复遍历，所以只要存在则返回真
        if node:
            return True
        return False

    def match(self, current, child, target):
        # 题目要求 child 必须为叶子节点，并且与之前值的和等于 target
        if not child.left and not child.right and current + child.val == target:
            return True
        return False
</code></pre></div></article></div></section><footer><div class="paginator"><a href="/2019/06/20/Anti-spam reviews in App Store/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'windsonYang';
var disqus_identifier = '2019/06/20/How to solve DFS problem in Leetcode/';
var disqus_title = 'How to Leetcode - DFS (To be finished)';
var disqus_url = 'https://windsooon.github.io/2019/06/20/How to solve DFS problem in Leetcode/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//windsonYang.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2019 <a href="https://windsooon.github.io">Unicooo</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>